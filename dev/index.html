<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Malt.jl · Malt</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Malt</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Malt.jl</a><ul class="internal"><li><a class="tocitem" href="#Malt-workers"><span>Malt workers</span></a></li><li><a class="tocitem" href="#Calling-Functions"><span>Calling Functions</span></a></li><li><a class="tocitem" href="#Evaluating-expressions"><span>Evaluating expressions</span></a></li><li><a class="tocitem" href="#Signals-and-Termination"><span>Signals and Termination</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Malt.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Malt.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaPluto/Malt.jl/blob/main/doc/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Malt.jl"><a class="docs-heading-anchor" href="#Malt.jl">Malt.jl</a><a id="Malt.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Malt.jl" title="Permalink"></a></h1><p>Malt is a multiprocessing package for Julia. You can use Malt to create Julia processes, and to perform computations in those processes. Unlike the standard library package <a href="https://docs.julialang.org/en/v1/stdlib/Distributed/"><code>Distributed.jl</code></a>, Malt is focused on process sandboxing, not distributed computing.</p><article class="docstring"><header><a class="docstring-binding" id="Malt" href="#Malt"><code>Malt</code></a> — <span class="docstring-category">Module</span></header><section><div><p>The Malt module doesn&#39;t export anything, use qualified names instead. Internal functions are marked with a leading underscore, these functions are not stable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPluto/Malt.jl/blob/d7e54df8e01f62cdadac4b0805d20befcf6b15fb/src/Malt.jl#L1-L5">source</a></section></article><h2 id="Malt-workers"><a class="docs-heading-anchor" href="#Malt-workers">Malt workers</a><a id="Malt-workers-1"></a><a class="docs-heading-anchor-permalink" href="#Malt-workers" title="Permalink"></a></h2><p>We call the Julia process that creates processes the <strong>manager,</strong> and the created processes are called <strong>workers.</strong> These workers communicate with the manager using the TCP protocol.</p><p>Workers are isolated from one another by default. There&#39;s no way for two workers to communicate with one another, unless you set up a communication mechanism between them explicitly.</p><p>Workers have separate memory, separate namespaces, and they can have separate project environments; meaning they can load separate packages, or different versions of the same package.</p><p>Since workers are separate Julia processes, the number of workers you can create, and whether worker execution is multi-threaded will depend on your operating system.</p><article class="docstring"><header><a class="docstring-binding" id="Malt.Worker" href="#Malt.Worker"><code>Malt.Worker</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Malt.Worker()</code></pre><p>Create a new <code>Worker</code>. A <code>Worker</code> struct is a handle to a (separate) Julia process.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; w = Malt.worker()
Malt.Worker(0x0000, Process(`…`, ProcessRunning))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPluto/Malt.jl/blob/d7e54df8e01f62cdadac4b0805d20befcf6b15fb/src/Malt.jl#L22-L33">source</a></section></article><h2 id="Calling-Functions"><a class="docs-heading-anchor" href="#Calling-Functions">Calling Functions</a><a id="Calling-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Calling-Functions" title="Permalink"></a></h2><p>The easiest way to execute code in a worker is with the <code>remotecall*</code> functions.</p><p>Depending on the computation you want to perform, you might want to get the result synchronously or asynchronously; you might want to store the result or throw it away. The following table lists each function according to its scheduling and return value:</p><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Scheduling</th><th style="text-align: left">Return value</th></tr><tr><td style="text-align: left"><a href="#Malt.remotecall"><code>Malt.remotecall</code></a></td><td style="text-align: left">Async</td><td style="text-align: left">&lt;value&gt;</td></tr><tr><td style="text-align: left"><a href="#Malt.remote_do"><code>Malt.remote_do</code></a></td><td style="text-align: left">Async</td><td style="text-align: left"><code>nothing</code></td></tr><tr><td style="text-align: left"><a href="#Malt.remotecall_fetch"><code>Malt.remotecall_fetch</code></a></td><td style="text-align: left">Blocking</td><td style="text-align: left">&lt;value&gt;</td></tr><tr><td style="text-align: left"><a href="#Malt.remotecall_wait"><code>Malt.remotecall_wait</code></a></td><td style="text-align: left">Blocking</td><td style="text-align: left"><code>nothing</code></td></tr></table><article class="docstring"><header><a class="docstring-binding" id="Malt.remotecall" href="#Malt.remotecall"><code>Malt.remotecall</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Malt.remotecall(f, w::Worker, args...; kwargs...)</code></pre><p>Evaluate <code>f(args...; kwargs...)</code> in worker <code>w</code> asynchronously. Returns a task that acts as a promise; the result value of the task is the result of the computation.</p><p>The function <code>f</code> must already be defined in the namespace of <code>w</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; promise = Malt.remotecall(uppercase ∘ *, w, &quot;I &quot;, &quot;declare &quot;, &quot;bankruptcy!&quot;);

julia&gt; fetch(promise)
&quot;I DECLARE BANKRUPTCY!&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPluto/Malt.jl/blob/d7e54df8e01f62cdadac4b0805d20befcf6b15fb/src/Malt.jl#L103-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Malt.remote_do" href="#Malt.remote_do"><code>Malt.remote_do</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Malt.remote_do(f, w::Worker, args...; kwargs...)</code></pre><p>Evaluate <code>f(args...; kwargs...)</code> in worker <code>w</code> asynchronously. Unlike <code>remotecall</code>, it discards the result of the computation, meaning there&#39;s no way to check if the computation was completed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPluto/Malt.jl/blob/d7e54df8e01f62cdadac4b0805d20befcf6b15fb/src/Malt.jl#L126-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Malt.remotecall_fetch" href="#Malt.remotecall_fetch"><code>Malt.remotecall_fetch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Malt.remotecall_fetch(f, w::Worker, args...; kwargs...)</code></pre><p>Shorthand for <code>fetch(Malt.remotecall(…))</code>. Blocks and then returns the result of the remote call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPluto/Malt.jl/blob/d7e54df8e01f62cdadac4b0805d20befcf6b15fb/src/Malt.jl#L141-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Malt.remotecall_wait" href="#Malt.remotecall_wait"><code>Malt.remotecall_wait</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Malt.remotecall_wait(f, w::Worker, args...; kwargs...)</code></pre><p>Shorthand for <code>wait(Malt.remotecall(…))</code>. Blocks and discards the resulting value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPluto/Malt.jl/blob/d7e54df8e01f62cdadac4b0805d20befcf6b15fb/src/Malt.jl#L151-L155">source</a></section></article><h2 id="Evaluating-expressions"><a class="docs-heading-anchor" href="#Evaluating-expressions">Evaluating expressions</a><a id="Evaluating-expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluating-expressions" title="Permalink"></a></h2><p>In some cases, evaluating functions is not enough. For example, importing modules alters the global state of the worker and can only be performed in the top level scope. For situations like this, you can evaluate code using the <code>remote_eval*</code> functions.</p><p>Like the <code>remotecall*</code> functions, there&#39;s different a <code>remote_eval*</code> depending on the scheduling and return value.</p><article class="docstring"><header><a class="docstring-binding" id="Malt.remote_eval" href="#Malt.remote_eval"><code>Malt.remote_eval</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Malt.remote_eval([m], w::Worker, expr)</code></pre><p>Evaluate expression <code>expr</code> under module <code>m</code> on the worker <code>w</code>. If no module is specified, <code>expr</code> is evaluated under <code>Main</code>. <code>Malt.remote_eval</code> is asynchronous, like <code>Malt.remotecall</code>.</p><p>The module <code>m</code> and the type of the result of <code>expr</code> must be defined in both the main process and the worker.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Malt.remote_eval(w, quote
    x = &quot;x is a global variable&quot;
end)

julia&gt; Malt.remote_eval_fetch(w, :x)
&quot;x is a global variable&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPluto/Malt.jl/blob/d7e54df8e01f62cdadac4b0805d20befcf6b15fb/src/Malt.jl#L163-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Malt.remote_eval_fetch" href="#Malt.remote_eval_fetch"><code>Malt.remote_eval_fetch</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Shorthand for <code>fetch(Malt.remote_eval(…))</code>. Blocks and returns the resulting value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPluto/Malt.jl/blob/d7e54df8e01f62cdadac4b0805d20befcf6b15fb/src/Malt.jl#L189-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Malt.remote_eval_wait" href="#Malt.remote_eval_wait"><code>Malt.remote_eval_wait</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Shorthand for <code>wait(Malt.remote_eval(…))</code>. Blocks and discards the resulting value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPluto/Malt.jl/blob/d7e54df8e01f62cdadac4b0805d20befcf6b15fb/src/Malt.jl#L196-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Malt.worker_channel" href="#Malt.worker_channel"><code>Malt.worker_channel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Malt.worker_channel(w::Worker, expr)</code></pre><p>Create a channel to communicate with worker <code>w</code>. <code>expr</code> must be an expression that evaluates to a Channel. <code>expr</code> should assign the Channel to a (global) variable so the worker has a handle that can be used to send messages back to the manager.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPluto/Malt.jl/blob/d7e54df8e01f62cdadac4b0805d20befcf6b15fb/src/Malt.jl#L203-L209">source</a></section></article><h2 id="Signals-and-Termination"><a class="docs-heading-anchor" href="#Signals-and-Termination">Signals and Termination</a><a id="Signals-and-Termination-1"></a><a class="docs-heading-anchor-permalink" href="#Signals-and-Termination" title="Permalink"></a></h2><p>Once you&#39;re done computing with a worker, or if you find yourself in an unrecoverable situation (like a worker executing a divergent function), you&#39;ll want to terminate the worker.</p><p>The ideal way to terminate a worker is to use the <code>stop</code> function, this will send a message to the worker requesting a graceful shutdown.</p><p>Note that the worker process runs in the same process group as the manager, so if you send a <a href="https://en.wikipedia.org/wiki/Signal_(IPC)">signal</a> to a manager, the worker will also get a signal.</p><article class="docstring"><header><a class="docstring-binding" id="Malt.isrunning" href="#Malt.isrunning"><code>Malt.isrunning</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Malt.isrunning(w::Worker)::Bool</code></pre><p>Check whether the worker process <code>w</code> is running.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPluto/Malt.jl/blob/d7e54df8e01f62cdadac4b0805d20befcf6b15fb/src/Malt.jl#L228-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Malt.stop" href="#Malt.stop"><code>Malt.stop</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Malt.stop(w::Worker)</code></pre><p>Try to terminate the worker process <code>w</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPluto/Malt.jl/blob/d7e54df8e01f62cdadac4b0805d20befcf6b15fb/src/Malt.jl#L236-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Malt.kill" href="#Malt.kill"><code>Malt.kill</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Malt.kill(w::Worker)</code></pre><p>Terminate the worker process <code>w</code> forcefully by sending a <code>SIGTERM</code> signal.</p><p>This is not the recommended way to terminate the process. See <code>Malt.stop</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPluto/Malt.jl/blob/d7e54df8e01f62cdadac4b0805d20befcf6b15fb/src/Malt.jl#L244-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Malt.interrupt" href="#Malt.interrupt"><code>Malt.interrupt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Malt.interrupt(w::Worker)</code></pre><p>Send an interrupt signal to the worker process. This will interrupt the latest request (<code>remotecall*</code> or <code>remote_eval*</code>) that was sent to the worker.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPluto/Malt.jl/blob/d7e54df8e01f62cdadac4b0805d20befcf6b15fb/src/Malt.jl#L254-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Malt.TerminatedWorkerException" href="#Malt.TerminatedWorkerException"><code>Malt.TerminatedWorkerException</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Malt will raise a <code>TerminatedWorkerException</code> when a <code>remotecall</code> is made to a <code>Worker</code> that has already been terminated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPluto/Malt.jl/blob/d7e54df8e01f62cdadac4b0805d20befcf6b15fb/src/Malt.jl#L15-L18">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Sunday 28 August 2022 21:23">Sunday 28 August 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
